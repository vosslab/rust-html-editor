#!/usr/bin/env python3
"""
Build-time code generator that reads config/menu_toolbar.yaml and produces:
  - src-tauri/src/generated_menu.rs   (Rust native menu bar)
  - src/generated_toolbar_data.js     (toolbar group definitions and active state checks)
  - src/generated_menu_actions.js     (editor command dispatcher for menu events)
"""

# Standard Library
import json
import os
import subprocess

# PIP3 modules
import yaml

# Header placed at the top of every generated file
GENERATED_HEADER_RUST = (
	"// AUTO-GENERATED by scripts/generate_menu_toolbar.py -- DO NOT EDIT\n"
	"// Source of truth: config/menu_toolbar.yaml\n"
)
GENERATED_HEADER_JS = (
	"// AUTO-GENERATED by scripts/generate_menu_toolbar.py -- DO NOT EDIT\n"
	"// Source of truth: config/menu_toolbar.yaml\n"
)


#============================================
def get_repo_root() -> str:
	"""Return the repository root directory using git."""
	result = subprocess.run(
		["git", "rev-parse", "--show-toplevel"],
		capture_output=True, text=True, check=True,
	)
	repo_root = result.stdout.strip()
	return repo_root


#============================================
def load_config(repo_root: str) -> dict:
	"""Load and validate the YAML configuration file."""
	config_path = os.path.join(repo_root, "config", "menu_toolbar.yaml")
	with open(config_path, "r") as f:
		config = yaml.safe_load(f)
	validate_config(config)
	return config


#============================================
def validate_config(config: dict) -> None:
	"""Validate the YAML config for common errors."""
	# Collect all menu item IDs and check for duplicates
	seen_ids = set()
	menu_count = 0
	for menu in config.get("menus", []):
		for item in menu.get("items", []):
			if isinstance(item, str):
				# separator
				continue
			item_id = item.get("id")
			if item_id:
				if item_id in seen_ids:
					raise ValueError(f"Duplicate menu ID: {item_id}")
				seen_ids.add(item_id)
				menu_count += 1
				# Every non-predefined item needs action or editor_command
				if "predefined" not in item:
					has_action = "action" in item
					has_editor = "editor_command" in item
					if not has_action and not has_editor:
						raise ValueError(
							f"Menu item '{item_id}' has neither 'action' nor 'editor_command'"
						)
			elif "predefined" not in item:
				raise ValueError(f"Menu item missing both 'id' and 'predefined': {item}")

	# Count toolbar buttons
	toolbar_count = 0
	for group in config.get("toolbar_groups", []):
		toolbar_count += len(group.get("buttons", []))

	print(f"Validated: {menu_count} menu items, {toolbar_count} toolbar buttons")


#============================================
def rust_predefined_name(kind: str) -> str:
	"""Map YAML predefined names to Rust PredefinedMenuItem method names."""
	mapping = {
		"about": "about",
		"hide": "hide",
		"hide_others": "hide_others",
		"show_all": "show_all",
		"quit": "quit",
		"cut": "cut",
		"copy": "copy",
		"paste": "paste",
		"select_all": "select_all",
	}
	if kind not in mapping:
		raise ValueError(f"Unknown predefined menu item: {kind}")
	return mapping[kind]


#============================================
def generate_rust_menu(config: dict) -> str:
	"""Generate the Rust source for setup_menu() from the YAML config."""
	lines = []
	lines.append(GENERATED_HEADER_RUST)
	lines.append('use tauri::menu::{MenuBuilder, MenuItemBuilder, PredefinedMenuItem, SubmenuBuilder};')
	lines.append('use tauri::Emitter;')
	lines.append('')
	lines.append('/// Build and attach the native macOS menu bar.')
	lines.append('pub fn setup_menu(app: &tauri::App) -> Result<(), Box<dyn std::error::Error>> {')

	submenu_vars = []

	for menu_idx, menu in enumerate(config["menus"]):
		menu_name = menu["name"]
		# Sanitize variable name: lowercase, replace spaces with underscores
		var_base = menu_name.lower().replace(" ", "_")
		submenu_var = f"{var_base}_menu"
		submenu_vars.append(submenu_var)

		lines.append(f'    // -- {menu_name} menu --')

		# Build items first, then chain into submenu
		item_vars = []
		for item_idx, item in enumerate(menu["items"]):
			# Handle bare string separator
			if isinstance(item, str) and item == "separator":
				item_vars.append("__separator__")
				continue

			# Handle separator dict (shouldn't happen but be safe)
			if isinstance(item, str):
				continue

			# Predefined items
			if "predefined" in item:
				kind = item["predefined"]
				method = rust_predefined_name(kind)
				item_var = f"{var_base}_{kind}"
				if kind == "about" and "about_name" in item:
					about_name = item["about_name"]
					lines.append(
						f'    let {item_var} = PredefinedMenuItem::{method}'
						f'(app, Some("{about_name}"), None)?;'
					)
				else:
					lines.append(
						f'    let {item_var} = PredefinedMenuItem::{method}(app, None)?;'
					)
				item_vars.append(item_var)
				continue

			# Regular menu items
			item_id = item["id"]
			label = item["label"]
			accel = item.get("accelerator")
			item_var = item_id

			if accel:
				lines.append(
					f'    let {item_var} = MenuItemBuilder::with_id("{item_id}", "{label}")'
				)
				lines.append(f'        .accelerator("{accel}")')
				lines.append('        .build(app)?;')
			else:
				lines.append(
					f'    let {item_var} = MenuItemBuilder::with_id("{item_id}", "{label}")'
				)
				lines.append('        .build(app)?;')

			item_vars.append(item_var)

		# Build the submenu
		lines.append('')
		lines.append(f'    let {submenu_var} = SubmenuBuilder::new(app, "{menu_name}")')

		for item_var in item_vars:
			if item_var == "__separator__":
				lines.append('        .separator()')
			else:
				lines.append(f'        .item(&{item_var})')

		lines.append('        .build()?;')
		lines.append('')

	# Build the full menu bar
	lines.append('    // -- Build the full menu bar --')
	lines.append('    let menu = MenuBuilder::new(app)')
	for var in submenu_vars:
		lines.append(f'        .item(&{var})')
	lines.append('        .build()?;')
	lines.append('')
	lines.append('    app.set_menu(menu)?;')
	lines.append('')

	# Menu event handler
	lines.append('    // -- Handle menu events by emitting to the frontend --')
	lines.append('    let app_handle = app.handle().clone();')
	lines.append('    app.on_menu_event(move |_app, event| {')
	lines.append('        let id = event.id().0.as_str();')
	lines.append('        // Emit a "menu-action" event to the frontend with the menu item id')
	lines.append('        let _ = app_handle.emit("menu-action", id);')
	lines.append('    });')
	lines.append('')
	lines.append('    Ok(())')
	lines.append('}')
	lines.append('')

	return '\n'.join(lines)


#============================================
def js_value(val) -> str:
	"""Convert a Python value to a JavaScript literal string."""
	if isinstance(val, str):
		return json.dumps(val)
	if isinstance(val, bool):
		return "true" if val else "false"
	if isinstance(val, (int, float)):
		return str(val)
	if isinstance(val, dict):
		pairs = []
		for k, v in val.items():
			pairs.append(f"{k}: {js_value(v)}")
		return "{ " + ", ".join(pairs) + " }"
	return json.dumps(val)


#============================================
def generate_js_toolbar(config: dict) -> str:
	"""Generate the JS toolbar data module from the YAML config."""
	lines = []
	lines.append(GENERATED_HEADER_JS)
	lines.append("")

	# -- toolbarGroups --
	lines.append("export const toolbarGroups = [")
	for group in config["toolbar_groups"]:
		dom_id = group.get("dom_id")
		visibility = group.get("visibility")
		lines.append("  {")
		lines.append(f'    name: {json.dumps(group["name"])},')
		if dom_id:
			lines.append(f'    id: {json.dumps(dom_id)},')
		lines.append("    buttons: [")
		for btn in group["buttons"]:
			parts = []
			parts.append(f'label: {json.dumps(btn["label"])}')
			parts.append(f'command: {json.dumps(btn["command"])}')
			if "args" in btn:
				parts.append(f"args: {js_value(btn['args'])}")
			parts.append(f'title: {json.dumps(btn.get("title", btn["label"]))}')
			lines.append("      { " + ", ".join(parts) + " },")
		lines.append("    ],")
		if visibility:
			lines.append(f'    visibility: {json.dumps(visibility)},')
		lines.append("  },")
	lines.append("];")
	lines.append("")

	# -- activeStateChecks --
	lines.append("export const activeStateChecks = [")
	for group in config["toolbar_groups"]:
		for btn in group["buttons"]:
			label = btn["label"]
			if "active_check" in btn:
				check = btn["active_check"]
				if "active_args" in btn:
					args = js_value(btn["active_args"])
					lines.append(
						f'  {{ label: {json.dumps(label)}, check: {json.dumps(check)}, args: {args} }},'
					)
				else:
					lines.append(
						f'  {{ label: {json.dumps(label)}, check: {json.dumps(check)} }},'
					)
			elif "active_check_attr" in btn:
				attr = js_value(btn["active_check_attr"])
				lines.append(
					f'  {{ label: {json.dumps(label)}, checkAttr: {attr} }},'
				)
	lines.append("];")
	lines.append("")

	# -- specialHandlers --
	lines.append("export const specialHandlers = {")
	for group in config["toolbar_groups"]:
		for btn in group["buttons"]:
			if "special" not in btn:
				continue
			command = btn["command"]
			special = btn["special"]
			if special == "prompt_url":
				prompt_text = btn.get("prompt_text", "Enter URL:")
				editor_cmd = btn.get("editor_command", btn["command"])
				args_key = btn.get("editor_args_key", "href")
				lines.append(f'  {json.dumps(command)}: {{')
				lines.append('    type: "prompt_url",')
				lines.append(f'    promptText: {json.dumps(prompt_text)},')
				lines.append(f'    editorCommand: {json.dumps(editor_cmd)},')
				lines.append(f'    argsKey: {json.dumps(args_key)},')
				lines.append('  },')
			elif special == "insert_table":
				lines.append(f'  {json.dumps(command)}: {{')
				lines.append('    type: "insert_table",')
				lines.append('  },')
	lines.append("};")
	lines.append("")

	# -- conditionalGroups --
	lines.append("export const conditionalGroups = [")
	for group in config["toolbar_groups"]:
		if "visibility" in group and "dom_id" in group:
			lines.append(
				f'  {{ domId: {json.dumps(group["dom_id"])}, '
				f'condition: {json.dumps(group["visibility"])} }},'
			)
	lines.append("];")
	lines.append("")

	return "\n".join(lines)


#============================================
def generate_js_menu_actions(config: dict) -> str:
	"""Generate the JS menu actions dispatcher from the YAML config."""
	lines = []
	lines.append(GENERATED_HEADER_JS)
	lines.append("")
	lines.append("/**")
	lines.append(" * Handle editor-command menu actions.")
	lines.append(" * Returns true if the action was handled, false otherwise.")
	lines.append(" */")
	lines.append("//============================================")
	lines.append("export function handleEditorMenuAction(editor, actionId) {")
	lines.append("  switch (actionId) {")

	action_count = 0
	for menu in config["menus"]:
		for item in menu["items"]:
			if isinstance(item, str):
				continue
			if "editor_command" not in item:
				continue
			item_id = item["id"]
			editor_cmd = item["editor_command"]
			editor_args = item.get("editor_args")
			editor_args_key = item.get("editor_args_key")
			action_type = item.get("action")

			# prompt_url items need special handling
			if action_type == "prompt_url":
				prompt_text = item.get("prompt_text", "Enter URL:")
				args_key = editor_args_key or "src"
				lines.append(f'    case "{item_id}": {{')
				lines.append(f'      const url = window.prompt({json.dumps(prompt_text)});')
				lines.append('      if (url) {')
				lines.append(
					f'        editor.chain().focus().{editor_cmd}'
					f'({{ {args_key}: url }}).run();'
				)
				lines.append('      }')
				lines.append('      return true;')
				lines.append('    }')
			elif editor_args is not None:
				# Command with arguments
				if isinstance(editor_args, dict):
					args_str = js_value(editor_args)
				else:
					args_str = json.dumps(editor_args)
				lines.append(f'    case "{item_id}":')
				lines.append(
					f'      editor.chain().focus().{editor_cmd}({args_str}).run();'
				)
				lines.append('      return true;')
			else:
				# Simple command, no arguments
				lines.append(f'    case "{item_id}":')
				lines.append(
					f'      editor.chain().focus().{editor_cmd}().run();'
				)
				lines.append('      return true;')

			action_count += 1

	lines.append("    default:")
	lines.append("      return false;")
	lines.append("  }")
	lines.append("}")
	lines.append("")

	print(f"Generated: {action_count} menu actions")
	return "\n".join(lines)


#============================================
def main() -> None:
	"""Entry point: load config, generate all output files."""
	repo_root = get_repo_root()
	config = load_config(repo_root)

	# Generate Rust menu
	rust_code = generate_rust_menu(config)
	rust_path = os.path.join(repo_root, "src-tauri", "src", "generated_menu.rs")
	with open(rust_path, "w") as f:
		f.write(rust_code)
	print(f"Wrote {rust_path}")

	# Generate JS toolbar data
	js_toolbar = generate_js_toolbar(config)
	js_toolbar_path = os.path.join(repo_root, "src", "generated_toolbar_data.js")
	with open(js_toolbar_path, "w") as f:
		f.write(js_toolbar)
	print(f"Wrote {js_toolbar_path}")

	# Generate JS menu actions
	js_actions = generate_js_menu_actions(config)
	js_actions_path = os.path.join(repo_root, "src", "generated_menu_actions.js")
	with open(js_actions_path, "w") as f:
		f.write(js_actions)
	print(f"Wrote {js_actions_path}")

	print("Done.")


if __name__ == '__main__':
	main()
